/****************************************************************************
* @file     02_二叉树的深度.c
* @brief    求二叉树的深度 
* @version  V1.00
* @date     2013.12.25
* @note     
****************************************************************************/
#include "stdio.h"
#include "malloc.h"

/**		节点数据类型  
*     
*		定义节点数据类型。    
*/
typedef char ElementType;

/**		树节点结构体定义  
*     
*		定义树节点所包含的成员变量。    
*/ 
typedef struct treenode
{
	int data;					/**< 节点数据 */  
	struct treenode* leftchild;		/**< 左孩子节点指针 */  
	struct treenode* rightchild;		/**< 右孩子节点指针 */  
} TreeNode, *TreeNode_ptr;

/** 
* @brief   使用先序遍历创建二叉树。
* @param   None
* @retval  TreeNode* 创建的树节点。
* @see     TreeNode;
* @note    scanf函数的问题：scanf会读入回车符，当需要一个一个的输入字符时，
			可以在%c前面加个空格
*/
TreeNode* Create_Binarytree()
{
	ElementType ch;
	TreeNode* T;
	scanf(" %c",&ch);    //这样调用scanf时，树的结点一次全部输入，如果要一次一个的输入，在%c前加个空格
	if(ch != '#')
	{
		if(NULL == (T = (TreeNode*)malloc(sizeof(TreeNode))))
		{
			perror("error...");
			exit(1);
		}
		T->data = ch;
		T->leftchild = Create_Binarytree();
		T->rightchild = Create_Binarytree();
	}
	else
	{
		T = NULL;
	}
	return T;
}

/** 
* @brief   输出输入二叉树的深度。
* @param   T：输入二叉树的根节点
* @retval  二叉树的深度。
* @see     TreeNode_ptr;
* @note    递归调用
*/
int BinaryTreeDepth(TreeNode_ptr T)
{
	if(NULL == T)
		return 0;
	int leftdepth, rightdepth;
	leftdepth = BinaryTreeDepth(T->leftchild);
	rightdepth = BinaryTreeDepth(T->rightchild);
	return (leftdepth > rightdepth) ? leftdepth+1 : rightdepth+1;
}

int main()
{
	TreeNode_ptr root= Create_Binarytree();
	printf("BinaryTreeDepth = %d\r\n", BinaryTreeDepth(root));
}